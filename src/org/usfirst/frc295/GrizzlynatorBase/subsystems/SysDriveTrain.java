// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc295.GrizzlynatorBase.subsystems;

import java.util.LinkedList;
import java.util.Queue;

import org.usfirst.frc295.GrizzlynatorBase.RobotMap;
import org.usfirst.frc295.GrizzlynatorBase.Drive.DriveSignal;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdLDecrement;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdDStepSize;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdDriveWithJoystick;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdHStepSize;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdLIncrement;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdRDecrement;
import org.usfirst.frc295.GrizzlynatorBase.commands.CmdRIncrement;

import com.ctre.CANTalon;
import com.ctre.CanTalonJNI;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Troubleshooting: 1. OPERATING THE JOYSTICK TO GO STRAIGHT SPINS THE ROBOT
 * Invert the "setInvertedMotor" statements for one side
 *
 * 2. OPERATING THE JOYSTICK TO TURN RIGHT TURNS THE ROBOT LEFT Invert the
 * "setInvertedMotor" statements for all motors
 */
public abstract class SysDriveTrain extends Subsystem
{

	protected DifferentialDrive _robotDrive;

	// SENSORS
	public Encoder _encoDriveRight;
	public Encoder _encoDriveLeft;
	protected Encoder _encoClimb;
	protected double QueueFull;
//	protected CANTalon _encoDriveRight;
	// Testing variables for encoders
	protected double LCount = 0;
	protected double CCount = 0;
	
	Preferences prefs = Preferences.getInstance();

	protected Queue<Double> LEncoRate = new LinkedList<Double>();
	protected Queue<Double> REncoRate = new LinkedList<Double>();
	protected Queue<Double> VoltageRate = new LinkedList<Double>();
	protected double RCount = 0;

	double VoltageSum = 0;
	double Voltage = 0;
	double LRateSum = 0;
	double RRateSum = 0;
	double LRate = 0;
	double RRate = 0;
	int AverageSize = 100;
	
	private int EncoCount = 0;
	
	private WPI_TalonSRX _escLeftFront;
	private WPI_TalonSRX _escLeftBack;
	private WPI_TalonSRX _escRightFront;
	private WPI_TalonSRX _escRightBack;
	
	private double StepSize = .05;
	
	public void Dstepsize() {
		StepSize = 0;
	}
	
	public void Hstepsize() {
		StepSize =0;
	}
	

		private double LTalonSpeedEnco = 0;
	
		public double LgetSpeed() {
			return LTalonSpeedEnco;
		}
		public void LDecrement() {
			LTalonSpeedEnco -= StepSize;
		}
	
		public void LIncrement() {
			LTalonSpeedEnco += StepSize;
		}
		
		private double RTalonSpeedEnco = 0;
		
		public double RgetSpeed() {
			return RTalonSpeedEnco;
		}
		public void RDecrement() {
			RTalonSpeedEnco -= StepSize;
		}
	
		public void RIncrement() {
			RTalonSpeedEnco += StepSize;
		}
	
		public void setLTalonSpeed() {
			_escLeftFront.set(LTalonSpeedEnco);
		}
		
		public void setRTalonSpeed() {
			_escRightFront.set(-1 * RTalonSpeedEnco);
		}
	
	public SysDriveTrain()
	{
		super();
		
		// ==========================================================
		// SYS DRIVE TRAIN
		// ==========================================================
		_escLeftFront = new WPI_TalonSRX(RobotMap.CAN_ESC_DRIVE_LEFT_FRONT);
		_escLeftBack = new WPI_TalonSRX(RobotMap.CAN_ESC_DRIVE_LEFT_BACK);
		_escRightFront = new WPI_TalonSRX(RobotMap.CAN_ESC_DRIVE_RIGHT_FRONT);
		_escRightBack = new WPI_TalonSRX(RobotMap.CAN_ESC_DRIVE_RIGHT_BACK);
	    _escLeftBack.follow(_escLeftFront);
	    _escRightBack.follow(_escRightFront);
		_robotDrive = new DifferentialDrive(_escLeftFront, _escRightFront);
		_robotDrive.setSafetyEnabled(true);
		_robotDrive.setExpiration(0.25);
		_robotDrive.setMaxOutput(1.0);
		_encoClimb = new Encoder(4, 5, false,
				EncodingType.k4X);
		_encoDriveLeft = new Encoder(2, 3, false, Encoder.EncodingType.k4X);
		_encoDriveLeft.setDistancePerPulse(1.0);
		_encoDriveRight = new Encoder(0, 1, false, Encoder.EncodingType.k4X);
		
		_encoDriveRight.setDistancePerPulse(1.0);
	}
	// THE ROBOT DRIVETRAIN'S VARIOUS STATES
	protected enum DriveControlState
	{
		OPEN_LOOP, BASE_LOCKED, VELOCITY_SETPOINT, VELOCITY_HEADING_CONTROL, PATH_FOLLOWING_CONTROL
	}

	protected DriveControlState _stateDriveControl = DriveControlState.OPEN_LOOP;





	@Override
	public void initDefaultCommand()
	{
		// Set the default command for a subsystem here.
		// DEFAULT FOR THIS SUBSYSTEM IS TO DRIVE WITH JOYSTICK
		setDefaultCommand(new CmdDriveWithJoystick());
	}



	
	public synchronized void setOpenLoop(DriveSignal signal)
	{
		if (_stateDriveControl != DriveControlState.OPEN_LOOP)
		{
			// _escLeftFront.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
			// _escRightFront.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
			_stateDriveControl = DriveControlState.OPEN_LOOP;
		}

		_robotDrive.tankDrive(signal.leftMotor, signal.rightMotor);
	
	
	}


	public synchronized void stop()
	{
		_robotDrive.stopMotor();
	}


	public synchronized void arcadeDrive(double move, double rotation)
	{
		_robotDrive.arcadeDrive(move, rotation);
	}
	public void printEncoData() {

		SmartDashboard.putNumber("LTalonSpeedEnco", LTalonSpeedEnco);
		SmartDashboard.putNumber("RTalonSpeedEnco", RTalonSpeedEnco);
		SmartDashboard.putNumber("LRate", LRate);
		SmartDashboard.putNumber("RRate", RRate);

		System.out.println("L:" + LTalonSpeedEnco +  " " + LRate + " |R:" + RTalonSpeedEnco + " " + RRate);
	  /*==================================================================================
	   * These are the commands that need to be called to precisely change the motor speed
	    ==================================================================================*/	
		SmartDashboard.putData("LIncrement", new CmdLIncrement());
		SmartDashboard.putData("LDecrement", new CmdLDecrement());
		SmartDashboard.putData("RIncrement", new CmdRIncrement());
		SmartDashboard.putData("RDecrement", new CmdRDecrement());
		SmartDashboard.putData("Increase Step Size", new CmdDStepSize());
		SmartDashboard.putData("Decrease Step Size", new CmdHStepSize());
//		SmartDashboard.putNumber("Count", EncoCount);
		if(EncoCount < AverageSize) {
			LRateSum += _encoDriveLeft.getRate();
			RRate += _encoDriveRight.getRate();
			LEncoRate.add(_encoDriveLeft.getRate());
			REncoRate.add(_encoDriveRight.getRate());
//			VoltageSum += _escLeftFront.getBusVoltage();
//			VoltageRate.add(_escLeftFront.getBusVoltage());
			EncoCount++;
//			QueueFull = 0;
		} else {
			LRateSum -= LEncoRate.remove();
			RRateSum -= REncoRate.remove();
			LRateSum += _encoDriveLeft.getRate();
			RRateSum += _encoDriveRight.getRate();
			LEncoRate.add(_encoDriveLeft.getRate());
			REncoRate.add(_encoDriveRight.getRate());
//			VoltageSum -= VoltageRate.remove();
//			VoltageSum += _escLeftFront.getBusVoltage();
//			VoltageRate.add(_escLeftFront.getBusVoltage());
//			QueueFull = 1;
		}
//		SmartDashboard.putNumber("Is Full" , QueueFull);
		Voltage = VoltageSum/AverageSize;
		LRate = LRateSum/AverageSize;
		RRate = RRateSum/AverageSize;
		
		if(LRate < .000001 && LRate > -.000001) {
			LRate = 0;
		}
		
		
//		System.out.println("Speed: " + getSpeed() + " | Rate: " + LRate + " | Voltage: " + Voltage + " | Inst: "+ _encoDriveLeft.getRate());
//		System.out.println("Raw" + _encoDriveLeft.get());
		
//		SmartDashboard.putNumber("Voltage", Voltage);
//		SmartDashboard.putNumber("Rate", LRate);
//		SmartDashboard.putNumber(, );
//		SmartDashboard.putNumber("Speed", getSpeed());

//		RRaw = _encoDriveRight.getRaw();
		RCount =  _encoDriveRight.get();
//		RDist = _encoDriveRight.getDistance();
		LCount = _encoDriveLeft.get();
		CCount = _encoClimb.get();
//		RRawA += _encoDriveRight.getRaw();
//		RCountA +=  _encoDriveRight.get();
//		RDistA += _encoDriveRight.getDistance();
		
		

//		System.out.println("L Rate is:" + LRate);
//		System.out.println("LCount is:" + LCount);

	}


	/**
	 * Reset the robots sensors to the zero states.
	 */
	public void reset()
	{
		// _gyro.reset();
//		_encoDriveRight.reset();
//		_encoDriveLeft.reset();
	}


	/**
	 * @return The robots heading in degrees.
	 */
	public double getHeading()
	{
		// return gyro.getAngle();
		return (0);
	}


	/**
	 * @return The distance driven (average of left and right encoders).
	 */
	public double getDistance()
	{
		return (_encoDriveRight.getDistance() + _encoDriveLeft.getDistance()) / 2;
	}


	/**
	 * @return The distance to the obstacle detected by the rangefinder.
	 */
	public double getDistanceToObstacle()
	{
		// Really meters in simulation since it's a rangefinder...
		// return rangefinder.getAverageVoltage();
		return (0);
	}


	/**
	 * The log method puts interesting information to the SmartDashboard.
	 */
//	public void logToSmartDashboard()
//	{
//		// SmartDashboard.putData("vibrate", new CmdHapticFeedback());
//		SmartDashboard.putNumber("Drive Encoder: Left Distance", _encoDriveLeft.getDistance());
//		SmartDashboard.putNumber("Drive Encoder: Right Distance", _encoDriveRight.getDistance());
//		SmartDashboard.putNumber("Drive Encoder: Left Speed", _encoDriveLeft.getRate());
//		SmartDashboard.putNumber("Drive Encoder: Right Speed", _encoDriveRight.getRate());
//	}
}
